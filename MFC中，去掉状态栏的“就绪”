
1.资源编辑器中，把每个菜单项的Prompt一栏 去掉(或者直接文本打开.rc，把不需要的替为空)........ 
2.搜索工程中"就绪", 应该在.rc中，把"就绪"换成"",  
3.更高级的办法是: 
响应WM_SETMESSAGESTRING消息: 
ON_MESSAGE(WM_SETMESSAGESTRING, OnSetMessageString) LRESULT CMainFrame::OnSetMessageString(WPARAM wParam, LPARAM lParam) 
{ 
LRESULT lr = CFrameWnd::OnSetMessageString(wParam, lParam); WPARAM w = AFX_IDS_IDLEMESSAGE; 
if (wParam == AFX_IDS_IDLEMESSAGE) 
{ 
m_wndStatusBar.SetPaneText(0, "", TRUE); //或者直接return lr;
} 
return lr; 
} 
如何动态的改变菜单项在状态栏中的提示： 
重载CFrameWnd的virtual void GetMessageString(UINT nID, CString& rMessage) const;函数

实现：
 -------------------------------------------------------------------------------- void CMainFrame::GetMessageString(UINT nID, CString& rMessage) const
 { 
if(nID == ID_FILE_NEW) //这里可以动态改变 
{ 
rMessage = "Create new file!"; 
return; 
} 
CFrameWnd::GetMessageString(nID,rMessage); //调用默认的处理过程 
} 

http://www.docin.com/p-93735033.html    

在MFC程序中如果使用默认的状态栏的话，其第一栏在空闲时显示的是“就绪”，如果用户点击菜单，还会用于显示菜单栏的提示文本，如“建立新文档”等。有时候我们不希望程序在状态栏中显示这些东西，那该怎么办呢？  
在MFC中，是用主框架类中的CStatusBar对象m_wndStatusBar来管理状态栏的。CStatusBar中有一个SetPaneText的函数可用于设置状态栏中的文字。我们在CMainFrame类中的OnCreate函数中添加  
m_wndStatusBar.SetPaneText(0, "Hello");  
则程序启动后，状态栏上显示的文字为“Hello”。但是当我们点击菜单后，会发现这段文字会消失，被替换成菜单的提示文本；若菜单操作结束，则又显示成“就绪”了。那该如何禁止MFC自动修改状态栏文本呢？  
我们再看看主框架类的源程序。当中有这么一段  
static UINT indicators[] = 
{ 
ID_SEPARATOR, 
ID_INDICATOR_CAPS, 
ID_INDICATOR_NUM, 
ID_INDICATOR_SCRL, 
};  

而在OnCreate中有这么一段  
m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)))  
这一句的作用是设置状态栏各部分的ID，默认的ID由indicators数组指定。由于MFC中把状态栏的第一栏设置为ID_SEPARATOR 了，这是一个MFC默认的ID，所以它有一系列默认的操作，如显示“就绪”二字。我们想禁止MFC自动操作状态栏就必须修改indicators数组。  
我们打开Resource View，修改String Table，找到那堆ID_INDICATOR开头的，在后面新加一个ID_INDICATOR_1。然后修改CMainFrame中indicators的声明  
static UINT indicators[] = 
{ 
ID_INDICATOR_1, 
ID_INDICATOR_CAPS, 
ID_INDICATOR_NUM, 
ID_INDICATOR_SCRL, 
};  
然后编译运行程序。我们会发现，MFC不会再自动修改状态栏的文本了，可是前面添加的一句 
m_wndStatusBar.SetPaneText(0, "Hello"); 
也不起作用了。这是为什么呢？  
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccore/html/_core_status_bars.3a_.updating_the_text_of_a_status.2d.bar_pane.asp 
MSDN上有一篇介绍如果修改状态栏文本的文章。当中有一句  
Note   The SetText approach is recommended. It is possible to perform this task at a slightly lower level by calling the CStatusBar member function SetPaneText. Even so, you still need an update handler. Without such a handler for the pane, MFC automatically disables the pane, erasing its content.  
意思大概是如果我们不为状态栏添加UPDATE的处理函数，MFC会自动禁止状态栏的该栏(pane)。按照MSDN的说法，我们需要增加UPDATE的处理函数。在MainFrm.h中添加 
afx_msg void OnUpdate1(CCmdUI *pCmdUI);  
在MainFrm.cpp中添加  
ON_UPDATE_COMMAND_UI(ID_INDICATOR_1, OnUpdate1)  
void CMainFrame::OnUpdate1(CCmdUI *pCmdUI) 
{  
pCmdUI->Enable(); 
}  
这样我们就可以往状态栏的第一栏写文字，而避开MFC对其的自动修改了。 
---------------- 
更新状态栏窗格文本  

本文解释如何更改出现在 MFC 状态栏窗格中的文本。状态栏（CStatusBar 类的一个窗口对象）包含几个“窗格”。每个窗格都是状态栏中可用来显示信息的矩形区域。例如，很多应用程序在最右边的窗格显示 CAPS LOCK、NUM LOCK 和其他键的状态。应用程序还经常在最左边的窗格（窗格 0）显示信息文本，此窗格有时称为“消息窗格”。例如，默认 MFC 状态栏使用消息窗格显示一个字符串，来解释当前选定的菜单项或工具栏按钮。状态栏中的图显示了由“应用程序向导”创建的 MFC 应用程序中的状态栏。  
默认情况下，MFC 在创建窗格时不启用 CStatusBar 窗格。若要激活一个窗格，必须对状态栏上的每一个窗格使用 ON_UPDATE_COMMAND_UI 宏并更新窗格。因为窗格不发送 WM_COMMAND 消息（与工具栏按钮不同），所以必须手动键入代码。  
例如，一个窗格以 ID_INDICATOR_PAGE 作为其命令标识符，并且包含文档的当前页码。以下过程描述如何在状态栏中新建一个窗格。  
新建窗格   
定义窗格的命令 ID。  
在“视图”菜单上单击“资源视图”。右击项目资源并单击“资源符号”。在“资源符号”对话框中，单击“新建”。键入一个命令 ID 名称：例如，ID_INDICATOR_PAGE。为 ID 指定值，或接受“资源符号”对话框建议的值。例如，对于 ID_INDICATOR_PAGE，接受默认值。关闭“资源符号”对话框。   
定义窗格中要显示的默认字符串。  
打开“资源视图”后，在为应用程序列出资源类型的窗口中双击“String Table”。打开“字符串表”编辑器后，从“插入”菜单中选择“新建字符串”。在“字符串属性”窗口中，选择窗格的命令 ID（例如：ID_INDICATOR_PAGE）并键入默认字符串值，如“Page   ”。关闭字符串编辑器。（需要一个默认字符串以避免编译器错误。）   
将该窗格添加到 indicators 数组。  
在文件 MAINFRM.CPP 中定位 indicators 数组。该数组按从左向右的顺序为状态栏的所有指示器列出了命令 ID。在数组中的适当位置，输入窗格的命令 ID，如以下为 ID_INDICATOR_PAGE 所显示的：   
static UINT BASED_CODE indicators[] = 
{    
 ID_SEPARATOR,           // status line indicator    
 ID_INDICATOR_CAPS,    
 ID_INDICATOR_NUM,   
 ID_INDICATOR_SCRL,     
ID_INDICATOR_PAGE, 
}; 
在窗格中显示文本的推荐方法是：在窗格的更新处理函数中调用 CCmdUI 类的 SetText 成员函数。例如，您也许想建立一个包含当前页码的整型变量 m_nPage，并使用 SetText 将窗格的文本设置为该页码的字符串形式。  
注意   建议使用 SetText 方法。可以通过调用 CStatusBar 成员函数 SetPaneText 在稍微低一些的级别执行该任务。即使如此，仍旧需要一个更新处理函数。如果窗格没有这样一个处理函数，MFC 会自动禁用该窗格并清除它的内容。 
以下过程显示如何使用更新处理函数在窗格中显示文本。  
创建窗格显示文本   
为命令添加命令更新处理函数。  
手动添加处理函数的原型，如在此为 ID_INDICATOR_PAGE 所显示的（在 MAINFRM.H 中）：   
afx_msg void OnUpdatePage(CCmdUI *pCmdUI); 
在适当的 .CPP 文件中，添加处理函数的定义，如在此为 ID_INDICATOR_PAGE 所显示的（在 MAINFRM.CPP 中）：   
void CMainFrame::OnUpdatePage(CCmdUI *pCmdUI) 
{    
 pCmdUI->Enable();  
} 
在适当的消息映射中，添加 ON_UPDATE_COMMAND_UI 宏，如在此为 ID_INDICATOR_PAGE 所显示的（在 MAINFRM.CPP 中）：
ON_UPDATE_COMMAND_UI(ID_INDICATOR_PAGE, OnUpdatePage) 
在处理函数中添加代码以显示文本。  
对于 ID_INDICATOR_PAGE，从上述步骤 1 中展开 OnUpdatePage 处理函数，添加最后三行：   
void CMainFrame::OnUpdatePage(CCmdUI *pCmdUI)  
{     
pCmdUI->Enable();      
CString strPage;     
strPage.Format( "Page %d", m_nPage );      
pCmdUI->SetText( strPage );  } 
定义了成员变量 m_nPage（属于 CMainFrame 类）的值后，该技术使页码在空闲处理过程中按应用程序更新其他指示器的相同方式出现在窗格中。如果 m_nPage 更改，则显示在下一个空闲循环过程中更改。
